/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package applications.rest;

import java.sql.*;
import java.util.*;
import spark.*;
import static spark.Spark.*;
import com.google.gson.Gson;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.nio.charset.StandardCharsets;
import java.math.BigInteger;

public class App {

    public static void main(String[] args) {
        var db = new Database("krusty.sqlite");
        port(8888);
        get("/ping", (req, res) -> db.ping(req, res));
        get("/customers", (req, res) -> db.getCustomers(req, res));
        get("/ingredients", (req, res) -> db.getMaterials(req, res));  
    }
}

class Database {

    /**
     * The database connection.
     */
    private Connection conn;

    /**
     * Creates the database interface object. Connection to the database is
     * performed later.
     */
    public Database(String filename) {
        openConnection(filename);
    }

    /**
     * Opens a connection to the database, using the specified filename (if we'd
     * used a traditional DBMS, such as PostgreSQL or MariaDB, we would have
     * specified username and password instead).
     */
    public boolean openConnection(String filename) {
        try {
            Class.forName("org.sqlite.JDBC");
            conn = DriverManager.getConnection("jdbc:sqlite:" + filename);
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Closes the connection to the database.
     */
    public void closeConnection() {
        try {
            if (conn != null) {
                conn.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * Checks if the connection to the database has been established
     * 
     * @return true if the connection has been established
     */
    public boolean isConnected() {
        return conn != null;
    }

    String ping(Request req, Response res) {
        var result = new String("\npong" + " " + res.status()) + "\n";
        res.status(200);
        return result;
    }

    public String getCustomers(Request req, Response res) {
        res.type("application/json");
        var query = "SELECT customer_name AS name, address\n" + "FROM customers\n";
        var params = new LinkedList<String>();
        try (var ps = conn.prepareStatement(query)) {
            var index = 0;
            for (var param : params) {
                ps.setString(++index, param);
            }
            var rs = ps.executeQuery();
            var result = JSONizer.toJSON(rs, "customers");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }

    public String getMaterials(Request req, Response res) {
        res.type("application/json");
        var query = "SELECT material_name AS name, amount AS quantity, unit\n" + "FROM materials\n";
        var params = new LinkedList<String>();
        try (var ps = conn.prepareStatement(query)) {
            var index = 0;
            for (var param : params) {
                ps.setString(++index, param);
            }
            var rs = ps.executeQuery();
            var result = JSONizer.toJSON(rs, "ingredients");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }
}

/**
 * Auxiliary class for automatically translating a ResultSet to JSON
 */
class JSONizer {

    public static String toJSON(ResultSet rs, String name) throws SQLException {
        StringBuilder sb = new StringBuilder();
        ResultSetMetaData meta = rs.getMetaData();
        boolean first = true;
        sb.append("{\n");
        sb.append("  \"" + name + "\": [\n");
        while (rs.next()) {
            if (!first) {
                sb.append(",");
                sb.append("\n");
            }
            first = false;
            sb.append("    {");
            for (int i = 1; i <= meta.getColumnCount(); i++) {
                String label = meta.getColumnLabel(i);
                String value = getValue(rs, i, meta.getColumnType(i));
                sb.append("\"" + label + "\": " + value);
                if (i < meta.getColumnCount()) {
                    sb.append(", ");
                }
            }
            sb.append("}");
        }
        sb.append("\n");
        sb.append("  ]\n");
        sb.append("}\n");
        return sb.toString();
    }

    private static String getValue(ResultSet rs, int i, int columnType) throws SQLException {
        switch (columnType) {
        case java.sql.Types.INTEGER:
            return String.valueOf(rs.getInt(i));
        case java.sql.Types.REAL:
        case java.sql.Types.DOUBLE:
        case java.sql.Types.FLOAT:
            return String.valueOf(rs.getDouble(i));
        default:
            return "\"" + rs.getString(i) + "\"";
        }
    }
}
