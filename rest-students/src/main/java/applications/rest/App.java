/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package applications.rest;

import java.sql.*;
import java.util.*;
import spark.*;
import static spark.Spark.*;
import com.google.gson.Gson;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.nio.charset.StandardCharsets;
import java.math.BigInteger;

public class App {

    public static void main(String[] args) {
        var db = new Database("movies.sqlite");
        port(7007);
        // before("/*", (req, res) -> appl.log(req.splat()[0]));
        get("/ping", (req, res) -> db.ping(req, res));
        post("/reset", (req, res) -> db.reset(req, res));
        get("/movies", (req, res) -> db.getMovies(req, res));
        get("/movies/:imdbKey", (req, res) -> db.getMovie(req, res, req.params(":imdbKey")));
        post("/performances", (req, res) -> db.postPerformance(req, res));
        get("/performances", (req, res) -> db.getPerformances(req, res));
        get("/customers/:id/tickets", (req, res) -> db.getTickets(req, res, req.params(":id")));
        post("/tickets", (req, res) -> db.postTicket(req, res));
        
    }
}

class Database {

    /**
     * The database connection.
     */
    private Connection conn;

    /**
     * Creates the database interface object. Connection to the database is
     * performed later.
     */
    public Database(String filename) {
        openConnection(filename);
    }

    /**
     * Opens a connection to the database, using the specified filename (if we'd
     * used a traditional DBMS, such as PostgreSQL or MariaDB, we would have
     * specified username and password instead).
     */
    public boolean openConnection(String filename) {
        try {
            Class.forName("org.sqlite.JDBC");
            conn = DriverManager.getConnection("jdbc:sqlite:" + filename);
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return false;
        }
        return true;
    }

    /**
     * Closes the connection to the database.
     */
    public void closeConnection() {
        try {
            if (conn != null) {
                conn.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * Checks if the connection to the database has been established
     * 
     * @return true if the connection has been established
     */
    public boolean isConnected() {
        return conn != null;
    }

    /* ================================== */
    /* --- insert your own code below --- */
    /* ===============================*== */

    public static String hash(String text) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(text.getBytes(StandardCharsets.UTF_8));
            byte[] digest = md.digest();
            return String.format("%064x", new BigInteger(1, digest));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    String ping(Request req, Response res) {
        var result = new String("\npong" + " " + res.status()) + "\n";
        res.status(200);
        return result;
    }

    String reset(Request req, Response res) {
        res.type("application/json");
        String[] statements = { "DELETE FROM theaters", "DELETE FROM movies", "DELETE FROM performances",
                "DELETE FROM users", "DELETE FROM tickets",
                "INSERT INTO users (user_name, name, password) " + "VALUES ('alice', 'Alice', '" + hash("dobido")
                        + "')",
                "INSERT INTO users (user_name, name, password) " + "VALUES ('bob', 'Bob', '" + hash("whatsinaname")
                        + "')",
                "INSERT INTO movies (title, year, imdb_key) VALUES ('The Shape of Water', '2017', 'tt5580390')",
                "INSERT INTO movies (title, year, imdb_key) VALUES ('Moonlight', '2016', 'tt4975722')",
                "INSERT INTO movies (title, year, imdb_key) VALUES ('Spotlight', '2015', 'tt1895587')",
                "INSERT INTO movies (title, year, imdb_key) VALUES ('Birdman', '2014', 'tt2562232')",
                "INSERT INTO theaters (theater_name, capacity) VALUES ('Kino', 10)",
                "INSERT INTO theaters (theater_name, capacity) VALUES ('SÃ¶dran', 16)",
                "INSERT INTO theaters (theater_name, capacity) VALUES ('Skandia', 100)" };

        try (var ps = conn.createStatement()) {
            for (String statement : statements) {
                ps.addBatch(statement);
            }
            var x = ps.executeBatch();
            res.status(200);
            return "\nOK\n";
        } catch (SQLException e) {
            e.printStackTrace();
            res.status(500);
            return "\nCould not insert values \n";
        }
    }

    public String getMovies(Request req, Response res) {
        res.type("application/json");

        var query = "SELECT imdb_key AS imdbKey, title, year\n" + "FROM movies\n" + "WHERE 1 = 1\n";
        var params = new LinkedList<String>();
        if (req.queryParams("title") != null) {
            query += "AND title = ? \n";
            params.add(req.queryParams("title"));
        }

        if (req.queryParams("year") != null) {
            query += "AND year = ? \n";
            params.add(req.queryParams("year"));
        }
        try (var ps = conn.prepareStatement(query)) {
            var index = 0;
            for (var param : params) {
                ps.setString(++index, param);
            }
            var rs = ps.executeQuery();
            var result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }

    String getMovie(Request req, Response res, String imdbKey) {
        res.type("application/json");
        var query = "SELECT imdb_key AS imdbKey, title, year\n" + "FROM   movies\n" + "WHERE  imdb_key = ?\n";

        try (var ps = conn.prepareStatement(query)) {
            ps.setString(1, imdbKey);
            var rs = ps.executeQuery();
            var result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }

    public String getTheaters(Request req, Response res) {
        res.type("application/json");

        var query = "SELECT *\n" + "FROM theaters\n" + "WHERE 1 = 1\n";
        var params = new LinkedList<String>();

        try (var ps = conn.prepareStatement(query)) {
            var index = 0;
            for (var param : params) {
                ps.setString(++index, param);
            }
            var rs = ps.executeQuery();
            var result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return "";
    }

    String postPerformance(Request req, Response res) {
        res.type("application/json");
        var statement = "INSERT \n" + "INTO performances(performance_id, imdb_key, theater_name, date, start_time)\n"
                + "VALUES  ((lower(hex(randomblob(16)))), ?, ?, ?, ?);";

        try (var ps = conn.prepareStatement(statement)) {
            conn.createStatement().execute("PRAGMA foreign_keys = ON");
            ps.setString(1, req.queryParams("imdb"));
            ps.setString(2, req.queryParams("theater"));
            ps.setString(3, req.queryParams("date"));
            ps.setString(4, req.queryParams("time"));

            if (ps.executeUpdate() != 1) {
                res.status(400);
                return "\nNothing inserted... \n";
            }
        } catch (SQLException e) {
            e.printStackTrace();
            return "\nNo such movie or theater \n";
        }

        var query = "SELECT performance_id\n" + "FROM performances\n" + "WHERE rowid = last_insert_rowid()";
        try (var ps = conn.prepareStatement(query)) {
            var rs = ps.executeQuery();
            if (rs.next()) {
                var id = rs.getString("performance_id");
                var result = String.format("\nperformances/%s\n }", id);
                res.status(201);
                res.body(result);
                return result;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        res.status(418);
        return "Error";
    }

    public String getPerformances(Request req, Response res) {
        res.type("application/json");

        var query = "SELECT performance_id AS performanceId, date, start_time AS startTime, year, theater_name AS theater,\n" + 
        "((SELECT capacity \n" + "FROM theaters\n" +"WHERE theaters.theater_name = performances.theater_name)\n" + "- (SELECT count(CASE performance_id WHEN tickets.performance_id = performances.performance_id THEN 1 ELSE null end)\n" +
        "FROM tickets)) AS remainingSeats\n"
                + "FROM performances\n" + "JOIN movies\n" + "USING(imdb_key)\n" + "JOIN theaters\n"
                + "USING(theater_name);";

        var params = new LinkedList<String>();
        try (var ps = conn.prepareStatement(query)) {
            var index = 0;
            for (var param : params) {
                ps.setString(++index, param);
            };
            var rs = ps.executeQuery();
            var result = JSONizer.toJSON(rs, "data");
            res.status(200);
            res.body(result);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return "\nThere are currently no performances\n";
    }

    String getTickets(Request req, Response res, String id) {
        res.type("application/json");

        var query = "SELECT date, start_time, theater_name, title, year, count() AS nbrOfTickets \n" + "FROM tickets \n"
                + "JOIN performances \n" + "USING(performance_id) \n" + "JOIN movies\n" + "USING(imdb_key)\n
                " +"GROUP BY performance_id \n"
                + "HAVING user_name = ?";

        try (var ps = conn.prepareStatement(query)) {
            ps.setString(1, id);
            var rs = ps.executeQuery();
            var result = JSONizer.toJSON(rs, "data");
            res.body(result);
            res.status(200);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
            return "\nThere are no tickets for this user\n";
        }
    }

    String postTicket(Request req, Response res) {
        res.type("application/json");

        var remainingSeats = "SELECT capacity - count()\n" + "FROM theaters\n" + "JOIN performances\n"
                + "USING (theater_name)\n" + "LEFT OUTER JOIN tickets\n" + "USING (performance_id)\n"
                + "GROUP BY performance_id\n" + "HAVING performance_id = ?;";

        try (var ps = conn.prepareStatement(remainingSeats)) {
            ps.setString(1, req.queryParams("performance"));
            var rsSeats = ps.executeQuery();

            if (rsSeats.next()) {
                var temp = rsSeats.getInt(1);
                if (temp < 1)
                    return "No tickets left";
            }
        } catch (SQLException e) {
            e.printStackTrace();
            return "Remaining seats";
        }

        var password = "SELECT password \n" + "FROM users \n" + "WHERE user_name =  ?";

        try (var ps = conn.prepareStatement(password)) {
            ps.setString(1, req.queryParams("user"));
            var rsPass = ps.executeQuery();

            if (rsPass.next()) {
                var passDB = rsPass.getString("password");
                if (!(req.queryParams(hash("pwd")).equals(hash("passDB")))){
                    return "Incorrect password";
                }
            }
        } catch (SQLException e) {
            e.printStackTrace();
            return "password";
        }

        var ticketStatement = "INSERT \n" + "INTO tickets(ticket_id, user_name, performance_id) \n" + "VALUES ((lower(hex(randomblob(16)))), ?, ?);";

        try (var ps = conn.prepareStatement(ticketStatement)) {
            conn.createStatement().execute("PRAGMA foreign_keys = ON");
            ps.setString(1, req.queryParams("user"));
            ps.setString(2, req.queryParams("performance"));
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
            return "tickets";
        }

        var returnTicket = "SELECT ticket_id \n" + "FROM tickets \n" + "WHERE rowid = last_insert_rowid()";

        try (var ps = conn.prepareStatement(returnTicket)) {
            var rs = ps.executeQuery();
            var id = rs.getString("ticket_id");
            var result = String.format("tickets/%s\n }", id);
            return result;
        } catch (SQLException e) {
            e.printStackTrace();
        }
        res.status(418);
        return "Error";
    }

}

/**
 * Auxiliary class for automatically translating a ResultSet to JSON
 */
class JSONizer {

    public static String toJSON(ResultSet rs, String name) throws SQLException {
        StringBuilder sb = new StringBuilder();
        ResultSetMetaData meta = rs.getMetaData();
        boolean first = true;
        sb.append("{\n");
        sb.append("  \"" + name + "\": [\n");
        while (rs.next()) {
            if (!first) {
                sb.append(",");
                sb.append("\n");
            }
            first = false;
            sb.append("    {");
            for (int i = 1; i <= meta.getColumnCount(); i++) {
                String label = meta.getColumnLabel(i);
                String value = getValue(rs, i, meta.getColumnType(i));
                sb.append("\"" + label + "\": " + value);
                if (i < meta.getColumnCount()) {
                    sb.append(", ");
                }
            }
            sb.append("}");
        }
        sb.append("\n");
        sb.append("  ]\n");
        sb.append("}\n");
        return sb.toString();
    }

    private static String getValue(ResultSet rs, int i, int columnType) throws SQLException {
        switch (columnType) {
        case java.sql.Types.INTEGER:
            return String.valueOf(rs.getInt(i));
        case java.sql.Types.REAL:
        case java.sql.Types.DOUBLE:
        case java.sql.Types.FLOAT:
            return String.valueOf(rs.getDouble(i));
        default:
            return "\"" + rs.getString(i) + "\"";
        }
    }
}
